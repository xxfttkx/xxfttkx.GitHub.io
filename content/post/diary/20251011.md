---
title: "20251011"
description: 
date: 2025-10-11T08:29:29+08:00
comments: true
draft: false
tags: ["diary"]
---
0147睡到0829，做了很有剧情的梦。

之前写的监听怪物死亡就去切线的代码被我同步改异步了，因为我认为这样更符合直觉，我觉得监听的类只需要监听就好了，我以为外面耗时的同步操作只要加个锁不要被监听的回调一直触发就好，结果就出问题了。监听类监听的是怪物血量，怪物死亡会触发回调，因为考虑没有怪物，需要设定个多少秒没遇到怪物就当成死亡，同样触发回调；之前触发回调时会同步寻路去具体路径，到了才开始判断，现在异步时会在触发完回调之后直接重置即时，那边还在寻路呢，这边就直接判断怪物死没死了，所以会导致提前认定怪物死亡，就出问题了。

`self.lock.acquire(blocking=False)`和自己写`self.lock = False`有什么区别

> 竞态条件（race condition）。锁底层是 **原子操作**，由 Python 解释器（或 asyncio 内部）保证互斥。

多线程用前者，后者只是个标记。

```
self.lock = threading.Lock()
if lock.acquire(blocking=False):
self.lock.release()
```

`asyncio.create_task()` 创建的协程任务运行在 **同一个线程的事件循环里**，没有真正的线程切换。

感觉可以完全不用`async`，全用`threading.Thread`，现在`async def`里调用了好几个耗时的普通函数太奇怪了。

不对，`async with session.get(self.enemy_url) as response:`这里要用异步？？

> **网络请求必须异步**，否则阻塞整个事件循环

什么叫`阻塞整个事件循环`，我如果开个线程来专门进行网络请求，理论上不是就算阻塞了也没影响的吗？

> 丢掉了 asyncio 的轻量并发优势

我可以在异步函数里`threading.Thread`吗

可以的兄弟可以的。算了，全改async得了，省点cpu？

我创建了`controller.task = asyncio.create_task(controller.switch_line(line, pos))`，在`switch_line`中，`time.sleep`和`asyncio.sleep`没区别？毕竟没东西能被我阻塞？

> **事件循环**是单线程的，负责调度所有协程

有的有的，创建这个协程的协程就被阻塞了。

所以异步函数里调用有一定耗时的同步函数的最好方法是把同步函数改成异步吗，好麻烦。

> 直接用`await asyncio.to_thread`包起来

但这样无法用`task.cancel`取消执行。

windows直接拖拽亮度slider无法改变显示器亮度，要通过显示器按钮独自设置，能代码控制吗？

> 你的显示器是外接的（HDMI / DP），而且系统层面控制不到背光。
>
> Windows 滑块只影响笔记本内屏（或支持的集成面板），外接显示器的亮度要通过 **DDC/CI 协议** 来调。

显示器关闭了竟然也能mss截图pyautogui点击啥的

> 因为 `mss` 本质上调用的是 Windows 的 **GDI（图形设备接口）**，
>
> 它截图的是「显卡帧缓冲（frame buffer）」里的内容，
> 
> 即使背光熄灭，只要帧缓冲仍然在输出，就能抓到画面。


